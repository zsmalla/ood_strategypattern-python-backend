# OOD_StrategyPattern
- 전략패턴 ©2021, sangjin@koreatech.ac.kr
- 패턴의 분류 : 행위 패턴
- 패턴의 목적
> This pattern defines a family of algorithms, encapsulates each one, and make them inter-changeable. It lets the algorithm vary independently from cilents that use it. -GoF-
- 패턴의 수준 : component
- 패턴의 적용
  - 한 행위를 다양하게 수행해야 하는 경우
  - 실행시간까지 객체의 행위 방법을 결정할 수 없는 경우
  - 행위를 수행하는 방법을 쉽게 추가하고 싶은 경우
  - 행위를 추가하면서 코드의 크기를 효과적으로 관리하고 싶을 경우
- 패턴 적용 가능 시나리오
  1) 게임에서 어떤 캐릭터가 다양한 무기를 사용하여 적을 공격할 수 있다.
  2) 게임에서 레벨에 따라 특정 유닛이 움직이는 방법이 다르다.
- 패턴의 참여자
  1) 전략 interface : 전략 메소드의 골격이 선언되어 있는 interface
  2) 전략 클래스 : 전략이 구체적으로 구현되어 있는 클래스. 보통 다수 존재.
  3) 클라이언트 클래스 : 전략을 활용하는 클래스
- 패턴의 구조

  ![image](https://user-images.githubusercontent.com/72483874/134005923-12e5d741-6072-440d-841d-5b069f17dd13.png)
- 참여자간 협력
  - 클라이언트는 전략 객체를 유지하기 위한 멤버 변수를 가지고 있으며, 이를 변경할 수 잇는 기본 수정자 메소드를 가지고 있아여 한다. 전략 객체를 이용하여 수행되는 행위를 가지고 있고, 보통 전략은 생성자를 통해 의존관계를 주입하는 형태가 가장 흔하다.
  - 전략 클래스는 약속된 전략 메소드를 가지고 있어야 한다.
- 패턴의 장단점
  - 장점
    - 전략을 쉽게 바꿀 수 있으며 실행시간에 변경할 수 있다.
    - 여러 종류의 행위가 전략 패턴으로 구현될 경우 이들의 조합으로 객체를 쉽게 구성할 수 있다.
    - 알고리즘 구현에 필요한 복잡한 자료구조를 클라이언트로부터 숨길 수 있다.
  - 단점
    - 행위의 모델링이 쉽지 않을 수 있다. 특히, <b>전략이 클라이언트의 상태가 필요한 경우</b> 효과적으로 이것을 설계하는 것이 어려울 수 있다.
- 패턴의 변형
  – 전략이 클라이언트 상태가 필요한 경우
    - 검토사항. 전략을 활용하는 클라이언트의 종류가 여러 개인 경우에는 이에 대한 고려가 필요함. 다양한 클라이언트가 전략을 활용하도록 효과적으로 추상화하는 것이 쉽지 않을 수 있음
    - 클라이언트의 상태를 전달하는 방법
      – 방법 1. 클라이언트 자체를 전달: 예) 오리 예제에서 오리 자체를 전달
      – 방법 2. 필요한 데이터만 전달: 예) 오리 예제에서 오리의 날개 정보만 전달
    - 방법 1은 결합성이 높아지는 단점이 있으며, 다른 종류의 클라이언트에서 전략을 사용하기 어려워질 수 있음.
    - 전략을 활용하는 클라이언트가 한 종류이고, 전략마다 활용하는 클라이언트의 상태가 다르면 이 방법이 방법 2보다는 효과적인 방법일 수 있음
    - 방법 1은 클라이언트와 전략 객체가 서로 의존하는 형태가 될 수 있음. 물론 둘 다 구체적인 클래스 대신에 추상 타입에 의존하도록 구현해야 함
    - 방법 2는 여러 전략에서 다른 데이터가 필요하면 이를 처리하기 쉽지 않을 수 있음
 - 관련 패턴 : 전략 클래스 객체가 불필요하게 많이 생성되는 것을 피하기 위해 싱글톤으로 구현하는 경우가 많음

# Description
### Koreatech 객체지향개발론 및 실습(CSE 434) : Laboratory 1. Strategy 패턴_묵찌빠 게임
![ezgif com-gif-maker](https://user-images.githubusercontent.com/72483874/134002028-b014c665-5569-4e6c-8d9e-580181e00fac.gif)
1. 목적
  - 알고리즘의 군을 정의하고 캡슐화해주며 서로 언제든지 바꿀 수 있도록 해주는 전략 패턴을 실습해본다.
  - 전략 패턴은 has-a 관계를 이용하며, OCP와 DIP 원칙에 충실한 행위 패턴이다.
2. 개요
  - 사용자와 컴퓨터 간에 묵찌빠를 하는 게임을 개발하고자 한다.
  - 컴퓨터가 묵찌빠를 제시하는 다양한 알고리즘을 만들어 필요하면 동적으로 바꾸고자 한다.
  - 이 실습에서는 <b>무조건 랜덤으로 묵찌빠를 결정하는 전략</b>과 <b>지난 번 상대방이 낸 손을 이용하여 묵찌빠를 결정</b>하는 두 가지 전략을 만들어 보고, 이 <b>두 전략 외에 새로운 전략</b>을 만들어 본다.
3. 묵찌빠 게임
  - 보통 GUI는 MVC(Model-View_Controller) 개념을 이용하여 전체 응용을 구성한다. 즉, 응용 로직, 화면 처리, 사용자 입력 처리를 분리하여 구현한다. 이와 관련 자세한 이론은 추후에 학습한다. 이 실습에서는 뷰 클래스와 모델 클래스로 나누어 응용을 구현한다. 구현한 뷰 클래스는 화면 처리와 사용자 입력 처리를 모두 담당하며, 모델 객체를 뷰의 멤버 변수로 생성하여 사용하고 있다.
4. Assignment
  - 실습에 제시된 2개의 전략 외에 새로운 전략 알고리즘을 구현하여 제출해야 한다. 새 알고리즘은 공격할 때와 수비할 때 서로 다른 전략을 사용해야 한다. 제출할 때 새 알고리즘을 고안한 배경을 상세히 전략을 구현한 파일의 프로그램 주석에 설명한다. 전략이 다양한 정보가 필요할 때 이것을 어떻게 효과적으로 추상화하는 것이 좋은지 생각해보고, 구현할 때 해당 고민을 바탕으로 구현한다.
####  GUI 코드 및 과제의 전반적인 출처 : ©2021, sangjin@koreatech.ac.kr
# Environment
python3 + PyQt5, IDE : PyCharm

# Files
### 1. gameview.py<br>
  사용자에게 보여지는 부분과 사용자의 입력 처리
### 2. computerplayer.py<br>
  묵찌빠, 가위바위보에서 컴퓨터 역할을 하는 클래스<br>
  전략패턴에서 전략을 활용하는 클라이언트 클래스
### 3. gamemodel.py<br>
  묵찌빠 게임에 필요한 데이터를 유지하고 게임 로직 제공
### 4. handtype.py<br>
  Handtype 열거형, GameResult 열거형 정의 
### 5. playingstrategy.py<br>
  전략패턴 : 전략 interface
  - RandomStrategy
  - LastHandBasedStrategy
  - UserAnalyzeStrategy

# Usage
excute gameview.py and enjoy 가위바위보 and 묵찌빠
